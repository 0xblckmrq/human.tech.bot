<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>role verification</title>
  <style>
    :root {
      --primary: #3458EA;
      --success: #63AD14;
      --highlight: #FFCC00;
      --background: #F4F7FB;
      --text-color: #111;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--background);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      margin: 0;
    }

    header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 30px;
    }

    header img {
      height: 60px;
      object-fit: contain;
    }

    header h1 {
      font-size: 1.9rem;
      margin: 0;
      color: var(--primary);
    }

    main {
      width: 100%;
      max-width: 650px;
      background: #fff;
      padding: 35px;
      border-radius: 14px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      border-top: 5px solid var(--primary);
    }

    .steps {
      display: flex;
      justify-content: space-between;
      margin-bottom: 25px;
    }

    .step {
      flex: 1;
      text-align: center;
      position: relative;
      font-size: 0.95rem;
      color: var(--primary);
      font-weight: 500;
    }

    .step.active {
      font-weight: bold;
      color: var(--highlight);
    }

    .step::before {
      content: '';
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--primary);
      display: block;
      margin: 0 auto 6px;
    }

    .step.active::before {
      background: var(--highlight);
    }

    .step::after {
      content: '';
      position: absolute;
      top: 7px;
      left: 50%;
      height: 2px;
      width: 100%;
      background: var(--primary);
      z-index: -1;
    }

    .step:last-child::after { display: none; }
    .step.active + .step::after { background: var(--highlight); }

    /* wallet buttons UI */
    .wallet-btns {
      display: flex;
      gap: 10px;
      margin: 12px 0 18px;
    }
    .wallet-btn {
      flex: 1;
      padding: 12px 0;
      border-radius: 10px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      color: #fff;
      transition: 0.2s;
    }
    .wallet-btn:hover { filter: brightness(1.08); }
    .wallet-btn.injected { background: #3458EA; }
    .wallet-btn.walletconnect { background: #3B99FC; }
    .wallet-btn.waap { background: #8A2BE2; }

    input#msg {
      width: 100%;
      font-family: monospace;
      font-size: 0.75rem;
      padding: 12px;
      margin-bottom: 20px;
      border: 2px solid var(--primary);
      border-radius: 10px;
      background: #fff;
      color: var(--text-color);
    }

    button#signBtn {
      padding: 14px 0;
      font-size: 1.1rem;
      border: none;
      border-radius: 10px;
      background: var(--primary);
      color: #fff;
      cursor: pointer;
      transition: 0.3s all;
      width: 100%;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    button#signBtn:hover {
      background: #2c47bf;
    }

    button.loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 24px;
      height: 24px;
      margin: -12px 0 0 -12px;
      border: 3px solid #fff;
      border-top: 3px solid var(--highlight);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 10;
    }

    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }

    #status {
      margin-top: 20px;
      font-size: 1rem;
      color: var(--primary);
      white-space: pre-wrap;
    }

    #signature {
      margin-top: 10px;
      font-size: 0.95rem;
      color: var(--success);
      word-break: break-word;
      font-family: monospace;
    }
  
    /* role assignment panel */
    .role-panel {
      margin-top: 22px;
      padding-top: 18px;
      border-top: 1px solid rgba(0,0,0,0.08);
    }
    .role-title {
      margin: 0 0 6px;
      font-size: 1.15rem;
      color: var(--text-color);
    }
    .role-subtitle {
      margin: 0 0 14px;
      color: rgba(17,17,17,0.7);
      font-size: 0.95rem;
      line-height: 1.35;
    }
    .role-list { display: flex; flex-direction: column; gap: 10px; }
    .role-item {
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 12px;
      padding: 12px 14px;
      display: flex;
      gap: 12px;
      align-items: flex-start;
    }
    .role-badge {
      min-width: 86px;
      text-align: center;
      font-weight: 800;
      font-size: 0.75rem;
      padding: 8px 10px;
      border-radius: 999px;
      align-self: center;
      user-select: none;
    }
    .role-badge.assigned {
      background: rgba(99,173,20,0.14);
      color: var(--success);
      border: 1px solid rgba(99,173,20,0.35);
    }
    .role-badge.not-assigned {
      background: rgba(0,0,0,0.05);
      color: rgba(17,17,17,0.75);
      border: 1px solid rgba(0,0,0,0.12);
    }
    .role-meta { flex: 1; }
    .role-name {
      margin: 0;
      font-size: 1rem;
      color: var(--text-color);
      font-weight: 750;
      letter-spacing: 0.2px;
    }
    .role-unlocks, .role-reason {
      margin: 4px 0 0;
      font-size: 0.92rem;
      line-height: 1.35;
    }
    .role-unlocks { color: rgba(17,17,17,0.78); }
    .role-reason { color: rgba(17,17,17,0.62); }
    .role-reason strong { color: rgba(17,17,17,0.78); }
    .role-footnote {
      margin: 14px 0 0;
      font-size: 0.9rem;
      color: rgba(17,17,17,0.7);
    }

  </style>
</head>
<body>
<header>
    <img src="/logo.png" alt="human.tech Logo">
    <h1>role verification</h1>
  </header>

  <main>
    <div class="steps">
      <div class="step" id="step1">Connect</div>
      <div class="step" id="step2">Sign</div>
      <div class="step" id="step3">Submit</div>
      <div class="step" id="step4">Verified</div>
    </div>

    <p>Connect your wallet used for the covenant and sign the challenge below.</p>

    <div id="walletRow" style="display:none; margin: 14px 0 18px; padding: 12px 14px; border: 1px solid rgba(0,0,0,0.08); border-radius: 12px; background: rgba(52,88,234,0.04);">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
        <div style="min-width: 240px;">
          <div style="font-size:0.85rem; color: rgba(17,17,17,0.65); margin-bottom:4px;">Connected wallet</div>
          <div id="connectedWallet" style="font-family: monospace; font-size:0.95rem; word-break: break-all;"></div>
        </div>
        <button id="changeWalletBtn" type="button" style="padding:10px 14px; border-radius:10px; border: 1px solid rgba(0,0,0,0.12); background:#fff; cursor:pointer; font-weight:700;">
          Change wallet
        </button>
      </div>
    </div>


    <div class="wallet-btns">
      <button class="wallet-btn injected" id="btnInjected" type="button">Browser Wallet</button>
      <button class="wallet-btn walletconnect" id="btnWC" type="button">WalletConnect</button>
      <button class="wallet-btn waap" id="btnWaaP" type="button">WaaP.xyz</button>
    </div>

    <input type="text" id="msg" readonly>

    <button id="signBtn" type="button">Connect & Sign</button>

    <p id="status"></p>
    <p id="signature"></p>

    <div id="rolePanel" class="role-panel" style="display:none;">
      <h2 class="role-title"></h2>
      <p class="role-subtitle"></p>
      <div id="roleList" class="role-list"></div>
      
    </div>

  </main>

  <!-- Keep: ethers UMD (known working) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>

  <!-- ✅ NEW: self-hosted bundle (Reown AppKit + WaaP) -->
  <!-- This file is generated at build time into: public/vendor/wallets.bundle.js -->
  <script src="/vendor/wallets.bundle.js"></script>

  <script>
    // Surface errors in UI (helps inside Discord browsers)
    window.addEventListener("error", (e) => {
      const el = document.getElementById("status");
      if (el) el.innerText = "❌ JS error: " + (e.message || "Unknown");
    });
    window.addEventListener("unhandledrejection", (e) => {
      const el = document.getElementById("status");
      if (el) el.innerText = "❌ Promise error: " + (e.reason?.message || e.reason || "Unknown");
    });

    document.addEventListener("DOMContentLoaded", () => {
      const WALLETCONNECT_PROJECT_ID = "458187c5895e1cb056679eedabc8f362";

      const params = new URLSearchParams(window.location.search);
      const challenge = params.get("challenge") || "";
      const userId = params.get("userId");

      const msgInput = document.getElementById("msg");
      const status = document.getElementById("status");
      const sigOutput = document.getElementById("signature");
      const btn = document.getElementById("signBtn");

      const step1 = document.getElementById("step1");
      const step2 = document.getElementById("step2");
      const step3 = document.getElementById("step3");
      const step4 = document.getElementById("step4");

      const btnInjected = document.getElementById("btnInjected");
      const btnWC = document.getElementById("btnWC");
      const btnWaaP = document.getElementById("btnWaaP");

      msgInput.value = challenge || "❌ No challenge received";

      let signer;
      let selected = "injected";
      let appkit = null; // Reown AppKit instance

      function setStatus(t) { status.innerText = t; }

      function updateStep(stepNum) {
        [step1, step2, step3, step4].forEach((el, idx) => {
          el.classList.toggle("active", idx < stepNum);
        });
      }

      // ---- Status (no signing needed) + Change wallet ----
      const walletRow = document.getElementById("walletRow");
      const connectedWalletEl = document.getElementById("connectedWallet");
      const changeWalletBtn = document.getElementById("changeWalletBtn");

      function shortAddr(a) {
        if (!a) return "";
        const s = String(a);
        if (s.length <= 14) return s;
        return s.slice(0, 6) + "…" + s.slice(-4);
      }

      function showLinkedWallet(wallet) {
        if (!walletRow || !connectedWalletEl) return;
        connectedWalletEl.innerText = wallet;
        walletRow.style.display = "block";
      }

      function hideLinkedWallet() {
        if (!walletRow) return;
        walletRow.style.display = "none";
        if (connectedWalletEl) connectedWalletEl.innerText = "";
      }

      async function loadStatus() {
        try {
          if (!userId) return;
          // same host as signature endpoint
          const resp = await fetch("https://human-tech-bot.onrender.com/api/status?userId=" + encodeURIComponent(userId.toString()), {
            method: "GET",
            headers: { "Accept": "application/json" }
          });
          const result = await resp.json();

          if (result && result.success) {
            // If backend knows wallet, show it
            const wallet = result?.inputs?.wallet || result?.wallet || null;
            if (wallet) showLinkedWallet(wallet);

            // If there are any assigned roles, render cards immediately
            const hasRoles =
              (Array.isArray(result?.assignedRoles) && result.assignedRoles.length > 0) ||
              (Array.isArray(result?.roles) && result.roles.length > 0) ||
              (typeof result?.roles === "string" && result.roles.trim().length > 0);

            if (hasRoles) {
              renderRolePanel(result);
            const wallet = result?.inputs?.wallet || result?.wallet;
            if (wallet) showLinkedWallet(wallet);
            // Once verified, keep UI minimal; hide connect/sign unless changing wallet
            btn.style.display = "none";
            document.querySelector(".wallet-btns").style.display = "none";
              updateStep(4);
              setStatus("This private channel will auto-delete.");
              // Hide connect/sign until user explicitly changes wallet
              btn.style.display = "none";
              document.querySelector(".wallet-btns").style.display = "none";
            }
          }
        } catch (e) {
          // Silent fail — status is convenience only
          console.warn("Status load failed:", e?.message || e);
        }
      }

      if (changeWalletBtn) {
        changeWalletBtn.addEventListener("click", () => {
          // Allow re-linking wallet by signing again
          document.querySelector(".wallet-btns").style.display = "flex";
          btn.style.display = "block";
          setStatus("Changing wallet: choose a wallet then click Connect & Sign.");
          // Keep cards visible until a new verification succeeds (less jarring).
          // If you prefer clearing them immediately, uncomment next 2 lines:
          // const rp = document.getElementById("rolePanel"); if (rp) rp.style.display = "none";
          // hideLinkedWallet();
        });
      }




      // ---- Role assignment UX ----
      // Roles + what they unlock (as requested)
      const ROLE_DEFS = [
        {
          key: "chosen_one",
          display: "Chosen One",
          unlocks: ['"the chosen people" channel'],
          covenant: false
        },
        {
          key: "og_humn",
          display: "O.G. HUMN",
          unlocks: ['"og humns" channel'],
          covenant: false
        },
        {
          key: "covenant_signatory_og",
          display: "Covenant Signatory O.G.",
          unlocks: ["covenant discussion channel", "meme contest channel"],
          covenant: true
        },
        {
          key: "covenant_verified_signatory",
          display: "Covenant Verified Signatory",
          unlocks: ["covenant discussion channel", "meme contest channel"],
          covenant: true
        }
      ];

      function normRoleKey(r) {
        return (r || "")
          .toString()
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "_")
          .replace(/[^a-z0-9_]/g, "");
      }

      function parseRoleList(v) {
        if (!v) return [];
        if (Array.isArray(v)) return v.map(normRoleKey).filter(Boolean);
        if (typeof v === "string") return v.split(",").map(normRoleKey).filter(Boolean);
        // if backend returns an object like { roleName: true }
        if (typeof v === "object") {
          return Object.entries(v)
            .filter(([_, val]) => !!val)
            .map(([k]) => normRoleKey(k));
        }
        return [];
      }

      function renderRolePanel(result) {
        const panel = document.getElementById("rolePanel");
        const list = document.getElementById("roleList");
        if (!panel || !list) return;

        const assigned = parseRoleList(result?.assignedRoles || result?.rolesAssigned || result?.roles || result?.assigned);
        const qualified = parseRoleList(result?.qualifiedRoles || result?.qualified || result?.eligibleRoles);
        const reasons = result?.roleReasons || result?.reasons || result?.ineligibleReasons || {};

        // if backend only returns "qualifiedRole" as a single string
        const qualifiedOne = normRoleKey(result?.qualifiedRole || result?.roleQualifiedFor || result?.qualified_for);
        if (qualifiedOne && !qualified.includes(qualifiedOne)) qualified.push(qualifiedOne);

        // If backend doesn’t return anything, we still show explicit “assigned/not assigned”
        const effectiveAssigned = new Set(assigned);
        const effectiveQualified = new Set(qualified);

        list.innerHTML = "";

        ROLE_DEFS.forEach((role) => {
          const isAssigned = effectiveAssigned.has(role.key) || effectiveAssigned.has(normRoleKey(role.display));
          const isQualified = effectiveQualified.has(role.key) || effectiveQualified.has(normRoleKey(role.display));

          const badgeText = isAssigned ? "ASSIGNED" : "NOT ASSIGNED";
          const badgeClass = isAssigned ? "assigned" : "not-assigned";

          // Reason priority:
          // - explicit reason from backend
          // - if qualified but not assigned, show that it’s pending / failed assignment
          // - otherwise show “not eligible”
          const backendReason =
            reasons?.[role.key] ||
            reasons?.[role.display] ||
            reasons?.[normRoleKey(role.display)] ||
            reasons?.[role.key.toUpperCase()] ||
            "";

          let reasonText = "";
          if (!isAssigned) {
            if (backendReason) reasonText = backendReason;
            else if (isQualified) reasonText = "You qualified, but the bot did not assign this role (check bot permissions / role hierarchy).";
            else {
              if (role.key === "chosen_one") {
                reasonText = "Human Passport score is below 70.";
              } else if (role.key === "og_humn") {
                reasonText = "Human Passport score is below 20.";
              } else {
                reasonText = "Not eligible based on your verification.";
              }
            }
            // Custom covenant messaging (requested)
            if (role.key === "covenant_signatory_og" && !backendReason && !isQualified) {
              reasonText = "You do not own the limited edition Human Tech Covenant Signatory.";
            }
            if (role.key === "covenant_verified_signatory" && !backendReason && !isQualified) {
              reasonText = "You are not verified as a signatory (not found in the manifest whitelist).";
            }
          } else {
            // If assigned, optionally show why/how
            if (backendReason) reasonText = backendReason;
            else if (isQualified) reasonText = "Qualified and successfully assigned.";
            else reasonText = "Assigned by the bot.";
          }

          const unlocks = role.unlocks.join(" + ");

          const item = document.createElement("div");
          item.className = "role-item";
          item.innerHTML = `
            <div class="role-badge ${badgeClass}">${badgeText}</div>
            <div class="role-meta">
              <p class="role-name">${role.display}${isQualified && !isAssigned ? " (Qualified)" : ""}</p>
              <p class="role-unlocks"><strong>Unlocks:</strong> ${unlocks}</p>
              ${!isAssigned ? `<p class="role-reason"><strong>Why:</strong> ${reasonText}</p>` : ``}
            </div>
          `;
          list.appendChild(item);
        });

        panel.style.display = "block";

        // Build a concise summary line for the main status text
        const assignedPretty = ROLE_DEFS
          .filter(r => effectiveAssigned.has(r.key) || effectiveAssigned.has(normRoleKey(r.display)))
          .map(r => r.display);

        const qualifiedPretty = ROLE_DEFS
          .filter(r => effectiveQualified.has(r.key) || effectiveQualified.has(normRoleKey(r.display)))
          .map(r => r.display);

        return { assignedPretty, qualifiedPretty };
      }
      async function submitSignature(sig) {
        step3.classList.add("active");
        btn.classList.remove("loading");
        try {
          sigOutput.innerText = sig;
          setStatus("Submitting signature to bot...");
          const resp = await fetch("https://human-tech-bot.onrender.com/api/signature", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId: userId.toString(), signature: sig })
          });
          const result = await resp.json();
          if (result.success) {
            step4.classList.add("active");
            renderRolePanel(result);
            const wallet = result?.inputs?.wallet || result?.wallet;
            if (wallet) showLinkedWallet(wallet);
            // Once verified, keep UI minimal; hide connect/sign unless changing wallet
            btn.style.display = "none";
            document.querySelector(".wallet-btns").style.display = "none";
            // Keep UI minimal — role cards are the source of truth
            setStatus("This private channel will auto-delete.");
            return;
          }

          // ✅ Retry-safe behavior:
          // If the user already has roles, do NOT show a failure just because
          // the verification session is no longer active. Just render the cards.
          const hasRoles =
            (Array.isArray(result?.assignedRoles) && result.assignedRoles.length > 0) ||
            (Array.isArray(result?.rolesAssigned) && result.rolesAssigned.length > 0) ||
            (Array.isArray(result?.roles) && result.roles.length > 0) ||
            (typeof result?.roles === "string" && result.roles.trim().length > 0) ||
            (typeof result?.assigned === "string" && result.assigned.trim().length > 0);

          if (hasRoles) {
            step4.classList.add("active");
            renderRolePanel(result);
            const wallet = result?.inputs?.wallet || result?.wallet;
            if (wallet) showLinkedWallet(wallet);
            // Once verified, keep UI minimal; hide connect/sign unless changing wallet
            btn.style.display = "none";
            document.querySelector(".wallet-btns").style.display = "none";
            setStatus("This private channel will auto-delete.");
            return;
          }

          // ❌ True failure (no roles to show)
          setStatus("❌ Verification failed: " + (result.error || "No active verification"));
          const rp = document.getElementById("rolePanel"); if (rp) rp.style.display = "none";
          } catch (err) {
          console.error(err);
          setStatus("❌ Error submitting signature: " + (err.message || err));
          const rp = document.getElementById("rolePanel"); if (rp) rp.style.display = "none";
        }
      }

      async function signChallenge() {
        step2.classList.add("active");
        const sig = await signer.signMessage(challenge);
        await submitSignature(sig);
      }

      // 1) Injected (known working)
      async function connectInjected() {
        if (!window.ethereum) {
          throw new Error("No browser wallet detected. Try WalletConnect or WaaP, or open in MetaMask/Rabby browser.");
        }
        const provider = new ethers.BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        return provider.getSigner();
      }

      // 2) WalletConnect via Reown AppKit (Option B)
      async function connectWithAppKit() {
        if (!window.__reown?.createAppKit) {
          throw new Error("Reown AppKit not loaded. Did /vendor/wallets.bundle.js build and deploy?");
        }

        if (!appkit) {
          const { createAppKit, EthersAdapter, mainnet, base } = window.__reown;
          const ethersAdapter = new EthersAdapter();

          appkit = createAppKit({
            adapters: [ethersAdapter],
            networks: [mainnet, base],
            projectId: WALLETCONNECT_PROJECT_ID,
            metadata: {
              name: "role verification",
              description: "Sign a challenge to verify and receive a Discord role",
              url: window.location.origin,
              icons: [window.location.origin + "/logo.png"]
            }
          });
        }

        appkit.open({ view: "Connect", namespace: "eip155" });

        const eip155Provider = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => reject(new Error("Timed out waiting for wallet connection.")), 60000);

          const unsub = appkit.subscribeProviders((state) => {
            const p = state && state["eip155"];
            if (p) {
              clearTimeout(timeout);
              try { unsub && unsub(); } catch (_) {}
              resolve(p);
            }
          });
        });

        appkit.close();

        const provider = new ethers.BrowserProvider(eip155Provider);
        await provider.send("eth_requestAccounts", []);
        return provider.getSigner();
      }

      // 3) WaaP.xyz
      async function connectWaaP() {
        if (!window.__initWaaP) {
          throw new Error("WaaP SDK not loaded. Did /vendor/wallets.bundle.js build and deploy?");
        }

        window.__initWaaP({
          config: {
            authenticationMethods: ["wallet"],
            styles: { darkMode: false }
          },
          walletConnectProjectId: WALLETCONNECT_PROJECT_ID,
          project: { name: "role verification" }
        });

        if (!window.waap?.login) {
          throw new Error("WaaP did not initialize (window.waap missing).");
        }

        const loginType = await window.waap.login();
        if (!loginType) throw new Error("WaaP login cancelled.");

        const provider = new ethers.BrowserProvider(window.waap);
        await provider.send("eth_requestAccounts", []);
        return provider.getSigner();
      }

      // UI events
      btnInjected.addEventListener("click", () => { selected = "injected"; setStatus("Selected: Browser Wallet"); });
      btnWC.addEventListener("click", () => { selected = "walletconnect"; setStatus("Selected: WalletConnect (AppKit)"); });
      btnWaaP.addEventListener("click", () => { selected = "waap"; setStatus("Selected: WaaP.xyz"); });

      btn.addEventListener("click", async () => {
        updateStep(1);
        btn.classList.add("loading");
        setStatus("Connecting...");

        try {
          if (selected === "injected") signer = await connectInjected();
          else if (selected === "walletconnect") signer = await connectWithAppKit();
          else if (selected === "waap") signer = await connectWaaP();
          else throw new Error("Unknown wallet selection.");

          setStatus("Wallet connected. Awaiting signature approval...");
          await signChallenge();
        } catch (err) {
          console.error(err);
          btn.classList.remove("loading");
          setStatus("❌ Wallet connection/signing error: " + (err.message || err));
        }
      });

      setStatus("Ready. Choose a wallet then click Connect & Sign.");
      loadStatus();
    });
  </script>
</body>
</html>
